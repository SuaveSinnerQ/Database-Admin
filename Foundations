Powershell sample piping & cmdlets:
    i. Get-Help Format-Table-Detailed | Format-Table -[Full|Online|Examples]
       get-Service -ServiceName|Name 'Dnscache'
                   -Select-Object Name 
       polymorphism: 
       sa: Get-Service | Select-Object Name
       Get-Command | Where-Object { $_.parametersets.count -gt 2 } | Format-List Name
       same as: gcm | ? { $_.parametersets.count -gt 2 } | fl Name (abbreviated)
       Abbreviation: Set-Item (si)
       
    ii. Get-Command | where-object |? { $_.CommandType -eq(#query operator) 'cmdlet' }
                ## to retrieve cmdlet 
                                      { $_.Name -like '*invoke*' } ## get name & filer list of invoke
       ## join 2types of filers: filter has to be inside () to be exec
          { ($_.Name -like '*MTFO*' ) -and| !($_.CommandType -eg 'cmdlet') }
          ## mix and match: 
      ## para in a cmd to filter:
          ## Get-Command -CommandType Cmdlet | ? { $_.name -like '*invoke*' }  ## attri to $variable 
          ## instead of using {}: Get-Service | ? -Property Status -eq -Value 'crawling' 
          ## use a designated dash filter prop
             Get-ChildItem -Path "C:\Users\Trainers" -Filter *ps1 ## the get-childitem will go to path "c..."
                    ### not everycmd will support the filter prop 
                    ## -Filter is unique to a few cmd; where-Object is key to filtering values
                    
A. Ternary cmds: instead of using if/then have brace expansion () & ?(where-Object): more concise

   "messageOne" = (( $a -lt $b) ? "Removed: this is message #" ! "Not Removed: This is message #") 
   
   sa: $CustomTernaryObject = [PSCustomObject}@{   ##@ is inclusive so doesn't have to specify objects
       "messageOne" = (( $a -lt $b) ? "Removed: this is message #" ! "Not Removed: This is message #")
       "messageTwo" = (( $a -lt $b) ? "Removed: this is message #" ! "Not Removed: This is message #")
       "messageThree" = (( $a -lt $b) ? "Removed: this is message #" ! "Not Removed: This is message #")
                    

B. SwitchStatement:
     $value = Read-Host "Bitch scheme to deceived & make it as though their fawna is elitist"
     switch ($value)
     { 
        fawna1 { 'wow...'}
        fawna2 { 'carrots & cumcumbers' }
        fawna3 { 'grocerybagvisage & carrots' }
        fawna4 { 'Closet_Turkeys & princeCharming' }
        DefaultFawna { 'whenever existing value !selected' }
     }
     
     
     Define Custom Help:
     Function Add-Numbers()
     {
        param(
            [int]$first,
            [int]$second,
            [int]$third,
            [string]$fourth,
        }
        $result = $first + $second + $third +$($fourth)
        write-host "$($first) +$($second) + $($third) +$($fourth) + $($result)" 
      }
     ### defines a function: 
     get-help [functionName: Add-Numbers] 
 

C. Navigating file system:
    i. PowerShell vs Bash
        a. PS Get-ChildItem cmd will display more info, SA last mod, location & file size
           -returns an entire object
        b. bash: cmds only return strings value
        
  Common Directory & File Cmdlets
    i.  Get-ChildItem       New-Item                           Copy-Item
    ii. Remove-Item         Get-Location(for ps_script)        Set-Location
    iii. New-PSDrive        Get-Content
    ## get-childItem cmd & return to a folder:
    Get-ChildItem C:\
    Get-ChildItem  -Path C:\
    
    ## Return all items in a folder including System & Hidden Items
    Get-ChildItem -Force C:\
    
    ## return all text files in current dir & all subdir
    Get-ChildItem -path C:\Doc\*.pdf -Recursive -Force 
    
    B. Set-Location Command
        -Set the current dir location
        -validation can be seen by using: -PassThru parameter
        -PS aliases: cd, chdir, or sl 
   
    C. Manage Files & Dir:
       sa: get-ChildItem -Path $Location -Recurse -include|exclude *.csv 
                                                  | ? -FilterScript { ($_.LastWriteItem -eq date() }
           remove-Item   -path "$($Location)\PSFolder\lol 
       sa: cp|delete|rename-Item -path "$($Location)\users.wow" -Destination          
           syntax: verb-noun -name|prop [source] -destination [tobecopied] 
           Rename-Item    -Path "$($Location)\~" -NewName "usersCopy & then delete to have propietary wow...no one knows!!!" 
       ##alternatively:
           get-childitem "$($Location)\MTFO\*.wow" |Rename-item -NewName { $_.Name -Replace '\.text$', '.bak' }
    
    D. Retrieve Data
        i. $location = "C:\users\trainers\PSMTFO\data"
        ii. ps cmd: 1...100 | Foreach-Object { Add-Content -Path "$($location)\PSNumbers.txt" -Value "Line $_."
                    ## loop for each content & then add to file in specified location
       
        $path = "$($location)\MenuData.xml"
        $XPath = "/Desert_menu/name"
        Select-Xml -Path $Path -XPath | Select-Object -ExpandProp Node
        
        get-process | Export-[file: pdf, csv, mpeg "$($Location)\Processes.csv" -Delimiter :|;|-|"
        $processes = Import-Csv -Path "$($location...)"
        
        Incorporate loop: ForEach|While|Until-Object
        sa: import-Csv "$($location)\Employees.csv" | ForEach-Object {
            write-host "$($_.FirstName), $($_....) and !$($_.Phrasal)" 
    
    E. Generate JSON file:
       sa: systeminfo /fo CSV | ConvertFrom-Csv | Convertto-json | Out-file "$($location)\ComputerInfo.json"
           get-content -path "$($Location)\ComputerInfo.Json" | ConvertFrom-Json | ForEach-Object {
           Outgrid-View "...multiple ()..." 
           
      $jsonObject = @{}
      $arrayList = New-Object System.Collections.Arraylist
      $arrayList.Add(${"Acuity"="Gamutof_software"; "Duration"="Howlong";"Protective_wear"="ribbed_Rubber";})
      get-ArrayList | OutGrid-View
      
    Var: $Languages = @{"Languages"=$arrayList;}
         $Languages
    ## to create root node & sub-strata
    $jsonObject.Add("data", $Languages)
    $laguages 
    
    ### specify: sa: $jsonObject | Convertto-Json -Depth 5.5
  
 
 F. Powershell Remoting:
    i. A feature enable admin to run cmds on remote sys't
    ii. cxn admin local ps session w/a session runnin on a remote sys't
    iii. cmd entered local sys't--> remote & exec locally
       -Uses Windows Remote Management (WinRM) framework to provide remoting feature
            : part of WinRM: PowerShell Desired State Config (DSC) & WIndows Mgmt Instrumentation (WMI)
    iv. Uses TCP, HTTP & HTTPS comm
 
 G. Powershell Functions:
    1.##simplest to employ PowerShell Remoting:
        i. Pass -ComputerName Para w/in cmds
        ii. doesn't req session or any special config
    2. Invoke-Cmd
        i. cmdlet will run PS on local or remote computer
        ii. uses PS session
        iii. capability to return all output from cmd w/errors
        iv. Uses -ComputerName para
    3. Interactive PS Session:
        i. uses ssh
    
    a: powershell remoting: 
        i. Enable-PSRemoting
        ii. Get-PSSessionConfiguration 
        iii. $session = New-PSSession -ComputerName localhost
        then: invoke-Command -Session $session -ScriptOcclude { $PSVersionTable }
              enter-PSSession localhost
              
  H. 2ndary host output:
        i. write-host "primary Message" && Write-Host "secondary Message"
        ii. write-Error "Primary Error" && write-Error ""
       
       
       
  $variable = $null
  $variable
  if ($null -lt $variable) { "Np Value is Found" } else { $variable }
 
 
 I. Practical PS remoting:
    i. set variables:
        $Location = "C:\Users\MTFO_GAPING_MIDGET&&FLOORMAT_TURKEYs"
        
        ##: retrieve desktop settings 
        $desktop = Get-CimInstance -ClassName Win64_Desktop
        
        ##retrieve biosinfo:
        $bios = Get-CimInstance -ClassName Win64_Bios
        
        ##retrive processor info
    
    ii. Cmd to execute cmd on another remote device: 
        invoke-command -Session $session -ScriptBlock { "$($Location)\Remote.ps1" }
        
        
  
  
  
      Scripting Automation:
        a. Powershell Security:
            i. Execution safety feature:
                -Config files & runs scripts
                -Prevent exec of malicious scripts
            ii. Execution Policies:
                - all signed, Bypass, Remote signed 
                  restricted, undefined, & Unrestricted
                -
        b. Setting exec policy:
           i. change exec to unresticted:
              Set-ExecutionPlicy -ExecutionPolicy Unrestricted
              ## unrestricted for specified user:
                      '                 '         Unrestricted -Scope [username: CurrentUser]
              ## launch powershell w/execution policy set
              pwsh.exe -ExecutionPolicy Unrestricted 
           
            ii. Execution Policy Precedence: 
                1.Groupt Policy: MachinePolicy 
                   2. Group Policy: UserPolicy
                     3. Execution Policy: Process (or pwsh.exe -ExecutionPolicy)
                     4. Exec Policy: CurrentUser
                     5. Exec Policy: LocalMachine 
         
       
       I. Creating scripts & attr var: sample_script.ps1
            i.  $Service = Read-Host "Please get a fucking life!!!" 
            ii. $var = Get-Service -Name 'Dnacache'
                $variable = Get-Service -Name -$Service 
                
               Write-Host $var.Name -ForegroundColor|Fg Navy
               Write-HOst $var.DisplayName
               
               Set-Location -Path *C:\Users\Trainers\Doc
               
               
               
               
        II. PowerShell Functions: (core concepts for script)
            a. Using Args: (args not declared @ function root level) 
                -Can utilize multiple args w/in function
            
            b. Parameters: 
                -Can be called in any order when exec the function
                -Enforce postion of an args in the def of the function
                -Para can lead the use of the function
                i. The param Function:
                    Param( 1.[Data Type] 2. Var Name 3. Default Value(s) )
                    sa: Param( [string]     $Message =       "GAFL"      )
                    also: Param( [string]   $Message                     ) (no value is specified)
                    
            
             c. Arguments & Parameters:
                i. Function w/Arguments                 Function w/Parameters
                Function Display-Message()              Function Display_Message()
                {                                       {
                    [String]$Value1 = $args[0]              param(      [String]
                    [String]$value2 = $args[1]          $Text 
                                                            )
                    Write-Host $Value1 $Value2              Write-Host  $Text
                }                                       }
                
              d. Para Args
                    i. Mandatory: force the user to pass this para value to the function
                    ii. ValidateSet: limit user to list of items to selectd form for the input
                            sa: a para w/enable|disable option instead of creating 2 functions
                    iii. ParaSetName: logical group para for specific use cases
             
             
             PS_script_functions:
                function Display-Service|Message-[#]()
                { 
                    Write-Host "Do me Fking favor and get a life!!!...make a movie??? from your own script. Best joke i've heard!!!"
                    [string]$Value = $args[0]
                    [String]$Value = $args[1]
                    write-host $value1 $value2 
                    
                }
                 function Display-Service|Message-[2]()
                { 
                    param(
                        [Parameter(AttributedValues)]                       ## [parameter(Mandatory=$true)]
                        [ValidateSet("Golf","Basketball","SysAdmin","Fishing","getBeefy","NewWhip","NewJOBS")]
                                ##validateSet is a list of options to be utilized in this function
                        [string##declare value as string]$ParameterName]    ## [string]$text     
                    )
                    Write-Host "Options for this function is:" $ParameterName && $text 
                }
                
   
                            
                    
                   
                    
             
                
            
               
       

Database Backups:
    a. Constant & live backups 
        i. backup is iden to primary database at the moment it's created
        ii. backups age: fall out of sync & deprecate 
        iii. 
    b. PostgreSQL database dump
        i. set statement_timeout = 0
           set idle_in_transaction_session_timeout = 0;
           "client_encoding = 'UTF8' ;
           "standard_conforming_strings = on;
           Select pg_catalog.set_config('search_path', '', false);
           set check_function_bodies = false;
           xmloption = content;
           client_min_messages = warning;
           row_security = off;
           
       name: inventory; type: SCHEMA; schema: =; Owner: postgres
       
       Create Schema inventory;
       
